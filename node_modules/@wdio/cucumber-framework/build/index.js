"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adapterFactory = exports.CucumberAdapter = exports.default = void 0;

var Cucumber = _interopRequireWildcard(require("cucumber"));

var _mockery = _interopRequireDefault(require("mockery"));

var _isGlob = _interopRequireDefault(require("is-glob"));

var _glob = _interopRequireDefault(require("glob"));

var _path = _interopRequireDefault(require("path"));

var _reporter = _interopRequireDefault(require("./reporter"));

var _hookRunner = _interopRequireDefault(require("./hookRunner"));

var _events = require("events");

var _config = require("@wdio/config");

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

class CucumberAdapter {
  constructor(cid, config, specs, capabilities, reporter) {
    this.cwd = process.cwd();
    this.cid = cid;
    this.specs = specs;
    this.reporter = reporter;
    this.capabilities = capabilities;
    this.config = config;
    this.cucumberOpts = Object.assign(_constants.DEFAULT_OPTS, config.cucumberOpts);
  }

  async run() {
    let runtimeError;
    let result;

    try {
      this.registerRequiredModules();
      Cucumber.supportCodeLibraryBuilder.reset(this.cwd);
      this.loadSpecFiles();
      this.wrapSteps();
      Cucumber.setDefaultTimeout(this.cucumberOpts.timeout);
      const supportCodeLibrary = Cucumber.supportCodeLibraryBuilder.finalize();
      const eventBroadcaster = new _events.EventEmitter();
      new _hookRunner.default(eventBroadcaster, this.config);
      const reporterOptions = {
        capabilities: this.capabilities,
        ignoreUndefinedDefinitions: Boolean(this.cucumberOpts.ignoreUndefinedDefinitions),
        failAmbiguousDefinitions: Boolean(this.cucumberOpts.failAmbiguousDefinitions),
        tagsInTitle: Boolean(this.cucumberOpts.tagsInTitle)
      };
      this.cucumberReporter = new _reporter.default(eventBroadcaster, reporterOptions, this.cid, this.specs, this.reporter);
      const pickleFilter = new Cucumber.PickleFilter({
        featurePaths: this.specs,
        names: this.cucumberOpts.name,
        tagExpression: this.cucumberOpts.tagExpression
      });
      const testCases = await Cucumber.getTestCasesFromFilesystem({
        cwd: this.cwd,
        eventBroadcaster,
        featurePaths: this.specs,
        order: this.cucumberOpts.order,
        pickleFilter
      });
      const runtime = new Cucumber.Runtime({
        eventBroadcaster,
        options: this.cucumberOpts,
        supportCodeLibrary,
        testCases
      });
      await (0, _config.executeHooksWithArgs)(this.config.before, [this.capabilities, this.specs]);
      result = (await runtime.start()) ? 0 : 1;

      if (this.cucumberOpts.ignoreUndefinedDefinitions && result) {
        result = this.cucumberReporter.failedCount;
      }
    } catch (e) {
      runtimeError = e;
      result = 1;
    }

    await (0, _config.executeHooksWithArgs)(this.config.after, [runtimeError || result, this.capabilities, this.specs]);

    if (runtimeError) {
      throw runtimeError;
    }

    return result;
  }

  registerRequiredModules() {
    this.cucumberOpts.requireModule.map(requiredModule => {
      if (Array.isArray(requiredModule)) {
        require(requiredModule[0])(requiredModule[1]);
      } else if (typeof requiredModule === 'function') {
        requiredModule();
      } else {
        require(requiredModule);
      }
    });
  }

  requiredFiles() {
    return this.cucumberOpts.require.reduce((files, requiredFile) => files.concat((0, _isGlob.default)(requiredFile) ? _glob.default.sync(requiredFile) : [requiredFile]), []);
  }

  loadSpecFiles() {
    _mockery.default.enable({
      useCleanCache: false,
      warnOnReplace: false,
      warnOnUnregistered: false
    });

    _mockery.default.registerMock('cucumber', Cucumber);

    this.requiredFiles().forEach(codePath => {
      const filepath = _path.default.isAbsolute(codePath) ? codePath : _path.default.join(process.cwd(), codePath);
      delete require.cache[require.resolve(filepath)];

      require(filepath);
    });

    _mockery.default.disable();
  }

  wrapSteps() {
    const wrapStepSync = this.wrapStepSync;
    const wrapStepAsync = this.wrapStepAsync;
    Cucumber.setDefinitionFunctionWrapper((fn, options = {}) => {
      const retryTest = isFinite(options.retry) ? parseInt(options.retry, 10) : 0;
      return fn.name === 'async' || !_config.hasWdioSyncSupport ? wrapStepAsync(fn, retryTest) : wrapStepSync(fn, retryTest);
    });
  }

  wrapStepSync(code, retryTest = 0) {
    return function (...args) {
      return (0, _config.runFnInFiberContext)(_config.executeSync.bind(this, code, retryTest, args)).apply(this);
    };
  }

  wrapStepAsync(code, retryTest = 0) {
    return function (...args) {
      return _config.executeAsync.call(this, code, retryTest, args);
    };
  }

}

exports.CucumberAdapter = CucumberAdapter;
const _CucumberAdapter = CucumberAdapter;
const adapterFactory = {};
exports.adapterFactory = adapterFactory;

adapterFactory.run = async function (...args) {
  const adapter = new _CucumberAdapter(...args);
  const result = await adapter.run();
  return result;
};

var _default = adapterFactory;
exports.default = _default;